---
layout: post
title: '[리눅스] 유닉스, 리눅스 과련된 깨알 지식'
date: 2015-09-18 00:00:00
categories: OS
tags: [OS, Linux, guide]
published: true
---

리눅스 정리라고 작성한 글에 잘못된 내용이 있다는 조언을 듣고 해당 부분에 대한 내용을 읽으며 이를 다른 분들께 전달하고 싶어 작성한다. 아래의 글은 페이스북의 김선영님께서 작성한 글을 가지고 왔다.

>유닉스, 리눅스 관련된 깨알 지식입니다.
>
> 1) 부모 프로세스가 죽는다고 자식 프로세스까지 죽지는 않습니다. 
부모(parent process)가 죽으면 자식(child process)은 고아 프로세스(orphan process)가 되고, step parent process로 최상위 프로세스(보통 init) 지정됩니다.
daemon 형태의 프로세스는 모두 orphan process 형태로 작성된답니다. (daemon은 세션을 새로 열고 stdio를 닫는 몇가지 작업을 더 필요로 합니다. 자세한 것은 system programming에서 배웁니다.) [1]
>
> 2) 포그라운드 프로세스란 세션내에서 제어터미널(controlling terminal)을 소유한 상태의 프로세스를 의미합니다. 만일 시험을 친다면 세션과 제어 터미널의 두 단어가 등장하지 않는다면 definition에서 틀린 것으로 간주할 수 있습니다. (이 정의는 IEEE std 1003.1 표준 문서에 등장합니다.) [2]
>
> 3) 백그라운드 프로세스란 세션내에서 제어터미널을 소유하지 못한 상태의 프로세스를 의미합니다. [3]
>
> 4) 리다이렉션은 입출력되는 스트림의 방향을 재지정하는 것을 의미합니다. 표준입출력만 재지정할 수 있는 것은 아닙니다. 시스템에 이미 작성되어있는 많은 쉘 스크립트들이 특정 파일서술자(file descriptor)를 직접 열어서 리다이렉션을 하고 있습니다.
예를 들어 read v_input <&10 처럼 명령하면 10번 fd로부터 방향 재지정을 통해 값을 읽어올 수 있습니다.
>
> 5) kill은 프로세스를 죽이는게 아닙니다.
프로세스에 시그널을 송신하는 것이 정확한 기능입니다. 초기 유닉스 설계시에는 시그널은 프로세스를 죽이는 용도로 썼기 때문에 붙여졌던 이름이지만 현대에는 프로세스를 죽이지 않는 여러 시그널이 늘어났기 때문입니다.
>PS. 얼마전 강의를 위해 리눅스 교재를 보러 서점에 갔는데, 서점에 있는 리눅스 교재 중 상당수가 위 개념을 잘못 설명하고 있더군요. 혹시라고 잘못 배우신 분들은 이 기회에 올바른 지식으로 업데이트 하시기 바랍니다.
특히 부모 프로세스 죽는다고 자식 프로세스가 죽는 경우는 없습니다. 로그오프 했을때 자식 프로세스들이 종료되는 것은 SIGHUP의 영향입니다. nohup 명령어가 바로 SIGHUP 시그널을 막아서 로그오프시 세션에 존재하는 프로세스 그룹의 연쇄 종료를 막아주는 기능입니다.
또한 백그라운드 프로세스가 뒤에서 작동하면서 화면에 나타나지 않는다고 설명하는 경우도 있었는데 find / & 로 작동시켜보시면 백그라운드로 작동하더라도 얼마든지 화면출력은 가능합니다. 단지 CTRL-C를 눌러서 SIGINT를 보내보면 백그라운드는 제어 터미널을 소유하지 못했기 때문에 종료가 안되는 것뿐이죠.
혹시라도 크로스 체크 하실 분들을 위해 참조 서적, 레퍼런스 사이트 목록.

>[1] APUE Chapter 9 Orphaned Process 정의 참조
>
>[2] [IEEE std. 1003.1](http://www.opengroup.org)의 foreground process 참조
>
>[3] [IEEE std. 1003.1](http://www.opengroup.org)의 background process 참조

하단의 글은 해당글에 달린 댓글의 정광섭님께서 추가로 말씀해주신 글입니다.

>한 가지 깨알 지식을 추가하면 프로세스 종료시에 kill -9 로 죽이는 경우가 있는데 이는 절대 피해야할 습관입니다. 보통 잘 만든 프로그램은 종료 시그널(SIGINT, SIGTERM 등)을 받으면 사용하던 리소스를 정리하고 파일을 닫고 마무리(시그널 핸들러) 하도록 구현되어 있는데 SIGKILL 과 SIGSTOP을 보내면은 핸들러를 호출할수 없으므로 사용하던 리소스가 깨진다거나 하는 문제가 발생할 수 있습니다.
>
>리눅스 책 광고를 하나 올리겠습니다. 입문서는 아니지만 위와같은 깨알 지식과 Redhat/CentOS 리눅스 기반으로 인프라를 구축하는 내용인 "리눅스를 활용한 회사 인프라 구축의 모든 것" 이라는 책이 있습니다. CentoOS 6 기준이긴 하지만 도움이 되실수 있을 것 같아서 올려봅니다. (CentOS 7 에 맞게 개정판을 내고 싶은데 책이 잘 안 팔립니다. ^^) http://www.yes24.com/24/goods/15542130?scode=032&OzSrank=7